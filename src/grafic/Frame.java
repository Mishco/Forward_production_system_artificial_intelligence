package grafic;

import java.util.AbstractList;
import java.util.ArrayList;
import java.util.List;
import main.OpenFile;
import main.Pravidlo;
import main.Solver;

/**
 *
 * @author Michal
 */
public class Frame extends javax.swing.JFrame {

    List<String> Pamat = new ArrayList<>();
    List<Pravidlo> vsetkyPravidla = new ArrayList<>();
    List<String[]> aplikovatelneAkcie = new ArrayList<>();
    List<String> vypisaneSpravy = new ArrayList<>();
    List<List<String>> filtrovaneINSTANCIEpravidiel;

    /**
     * Creates new form Frame
     */
    public Frame() {
        initComponents();

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTextFakty = new javax.swing.JTextArea();
        jBtnNacitajFakty = new javax.swing.JButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextPravidla = new javax.swing.JTextArea();
        jBtnNacitajPravidla = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTextPomocnyVystup = new javax.swing.JTextArea();
        jBtnJedenKrok = new javax.swing.JButton();
        jBtnVsetkyKroky = new javax.swing.JButton();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTextSprava = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jTextFakty.setColumns(20);
        jTextFakty.setRows(5);
        jScrollPane1.setViewportView(jTextFakty);

        jBtnNacitajFakty.setText("Nacitaj fakty");
        jBtnNacitajFakty.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jBtnNacitajFaktyActionPerformed(evt);
            }
        });

        jTextPravidla.setColumns(20);
        jTextPravidla.setRows(5);
        jScrollPane2.setViewportView(jTextPravidla);

        jBtnNacitajPravidla.setText("Nacitaj pravidla");
        jBtnNacitajPravidla.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jBtnNacitajPravidlaActionPerformed(evt);
            }
        });

        jTextPomocnyVystup.setColumns(20);
        jTextPomocnyVystup.setRows(5);
        jScrollPane3.setViewportView(jTextPomocnyVystup);

        jBtnJedenKrok.setText("Jeden krok");
        jBtnJedenKrok.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jBtnJedenKrokActionPerformed(evt);
            }
        });

        jBtnVsetkyKroky.setText("Vsetky kroky");
        jBtnVsetkyKroky.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jBtnVsetkyKrokyActionPerformed(evt);
            }
        });

        jTextSprava.setColumns(20);
        jTextSprava.setRows(5);
        jScrollPane4.setViewportView(jTextSprava);

        jLabel1.setText("sprava");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 258, Short.MAX_VALUE)
                    .addComponent(jBtnNacitajFakty)
                    .addComponent(jScrollPane4)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jBtnJedenKrok)
                        .addGap(18, 18, 18)
                        .addComponent(jBtnVsetkyKroky)))
                .addGap(36, 36, 36)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jBtnNacitajPravidla)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 385, Short.MAX_VALUE)
                    .addComponent(jScrollPane2))
                .addContainerGap(49, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(7, 7, 7)
                        .addComponent(jBtnNacitajFakty))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jBtnNacitajPravidla)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 224, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel1)
                            .addComponent(jBtnJedenKrok)
                            .addComponent(jBtnVsetkyKroky))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 111, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 228, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(46, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    //nacitanie FAKTOV
    @SuppressWarnings("static-access")
    private void jBtnNacitajFaktyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jBtnNacitajFaktyActionPerformed
        jTextFakty.setText("");
        jTextSprava.setText("");
        jTextPomocnyVystup.setText("");
        jBtnVsetkyKroky.setEnabled(true);

        OpenFile open = new OpenFile();
        Pamat = open.openFakty();
        //System.out.println(Pamat);
        StringBuilder FaktyNaVypis = new StringBuilder();

        for (String s : Pamat) {
            FaktyNaVypis.append(s).append("\n");
        }
        String tmp = new String(FaktyNaVypis);
        jTextFakty.append(tmp);
    }//GEN-LAST:event_jBtnNacitajFaktyActionPerformed

    //nacitanie PRAVIDLA
    @SuppressWarnings("static-access")
    private void jBtnNacitajPravidlaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jBtnNacitajPravidlaActionPerformed
        jTextPravidla.setText("");

        OpenFile open = new OpenFile();
        List<String> vypisPravidla = open.PravidlaNaVypis();
        StringBuilder PravidlaNaVypis = new StringBuilder();

        //pracovna cast pravidiel
        vsetkyPravidla = open.openPravidla();

        for (String strings : vypisPravidla) {
            PravidlaNaVypis.append(strings).append("\n");
        }
        String tmp = new String(PravidlaNaVypis);
        jTextPravidla.append(tmp);
    }//GEN-LAST:event_jBtnNacitajPravidlaActionPerformed

    //VSETKY KROKY NARAZ
    private void jBtnVsetkyKrokyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jBtnVsetkyKrokyActionPerformed
        //riesenie cez vsetky pravidla
        Working(vsetkyPravidla);
    }//GEN-LAST:event_jBtnVsetkyKrokyActionPerformed
    //JEDEN KROK
    private void jBtnJedenKrokActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jBtnJedenKrokActionPerformed

        jBtnVsetkyKroky.setEnabled(false);
        WorkingSTEPbySTEP(vsetkyPravidla);
    }//GEN-LAST:event_jBtnJedenKrokActionPerformed
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    public void WorkingSTEPbySTEP(List<Pravidlo> vsetkyPravidla) {
        StringBuilder VYPIS = new StringBuilder();

        aplikovatelneAkcie = new ArrayList<>();

        //znova ako pri predoslom pripade, ale nejdem v cykle ale iba raz
        for (Pravidlo prav : vsetkyPravidla) {
            List<String[]> naviazania = new ArrayList<>();
            searching(prav.Nazov, prav.Podmienka, prav.Akcia, naviazania);
        }
        filtrovaneINSTANCIEpravidiel = new ArrayList<>();

        for (String[] inst : aplikovatelneAkcie) {
            List<String> filtrovaneInstanciePravidla = new ArrayList<>();
            for (String s : inst) {
                String prikaz = s.substring(0, s.indexOf(" "));
                String tempFakt = s.substring(s.indexOf(" ") + 1, s.length());

                switch (prikaz) {
                    case "pridaj":
                        if (Pamat.contains(tempFakt) == false) {
                            String filterFakt = prikaz + " " + tempFakt;
                            filtrovaneInstanciePravidla.add(filterFakt);
                        }
                        break;
                    case "vymaz":
                        if (Pamat.contains(tempFakt) == true) {
                            String filterFakt = prikaz + " " + tempFakt;
                            filtrovaneInstanciePravidla.add(filterFakt);
                        }
                        break;
                    default:
                        if (vypisaneSpravy.contains(tempFakt) == false) {
                            String filterFakt = prikaz + " " + tempFakt;
                            filtrovaneInstanciePravidla.add(filterFakt);
                        }
                        break;
                }
            }
            if (filtrovaneInstanciePravidla.isEmpty() == false) {
                filtrovaneINSTANCIEpravidiel.add(filtrovaneInstanciePravidla);
            }
        }

        System.out.println(
                "Vypis aplikovatelnych instancii" + " velkost: " + aplikovatelneAkcie.size());
        // VYPIS.append("Vypis aplikovatelnych instancii" + " velkost: ").append(aplikovatelneAkcie.size()).append("\n");

        for (String[] inst : aplikovatelneAkcie) {
            for (String s : inst) {
                System.out.println(s);
            }
        }
        StringBuilder bb = new StringBuilder();
        bb.append("Vypis filtrovanych instancii, velkost: ").append(filtrovaneINSTANCIEpravidiel.size()).append("\n");

        for (List<String> inst
                : filtrovaneINSTANCIEpravidiel) {
            for (String s : inst) {
                bb.append(s).append(", ");
                System.out.println(s + "...");
            }
            bb.append("\n");
        }

        VYPIS.append(bb).append("\n");

        System.out.println("Velkost filtrovanych inst: " + filtrovaneINSTANCIEpravidiel.size());
        if (filtrovaneINSTANCIEpravidiel.size() > 0) {
            for (String s : filtrovaneINSTANCIEpravidiel.get(0)) {
                String prikaz = s.substring(0, s.indexOf(" "));
                String akcia = s.substring(s.indexOf(" ") + 1, s.length());

                switch (prikaz) {
                    case "pridaj":
                        if (Pamat.contains(akcia)) {
                            System.out.println("Duplicita v pamati: " + akcia);
                        } else {
                            System.out.println("Pridavam: " + akcia);
                            Pamat.add(akcia);
                            refreshPamatVypis();
                        }
                        break;
                    case "vymaz":
                        if (Pamat.contains(akcia)) {
                            System.out.println("Vymazavam: " + akcia);
                            Pamat.remove(akcia);
                            refreshPamatVypis();
                        } else {
                            System.out.println("nemozem vymazat, fakt neexistuje: " + akcia);
                        }
                        break;
                    case "sprava":
                        vypisaneSpravy.add(akcia);
                        System.out.println("Sprava: " + akcia);
                        jTextSprava.append(akcia + "\n");
                        jTextSprava.setCaretPosition(0);
                        break;
                }
            }
        }
        jTextPomocnyVystup.setText(null);
        jTextPomocnyVystup.setText(VYPIS.toString());
    }

    //--------------------------------------------------------------------------------------------------------------------------------------------------------------------------  
    public void Working(List<Pravidlo> vsetkyPravidla) {
        jTextSprava.setText("");
        StringBuilder temporaryVYPIS = new StringBuilder();
        StringBuilder VYPIS_APLIKOVATELNE = new StringBuilder();

        vypisaneSpravy = new ArrayList<>();
        do {
            aplikovatelneAkcie = new ArrayList<>();

            // ziskanie a a najdenie aplikovatelnych instancii
            for (Pravidlo prav : vsetkyPravidla) {
                List<String[]> naviazania = new ArrayList<>();
                searching(prav.Nazov, prav.Podmienka, prav.Akcia, naviazania);
            }
            filtrovaneINSTANCIEpravidiel = new ArrayList<>();

            //filtrovanie aplikovatelnych instancii
            for (String[] instancia : aplikovatelneAkcie) {

                List<String> filterPravidiel = new ArrayList<>();

                for (String s : instancia) {
                    String prikaz = s.substring(0, s.indexOf(" "));
                    String tempFakt = s.substring(s.indexOf(" ") + 1, s.length());
                    //prikaz ak ma nieco pridavat
                    switch (prikaz) {
                        case "pridaj":
                            //ak sa v pamati este nenachadza podobny prikaz
                            if (Pamat.contains(tempFakt) == false) {
                                String filterFakt = prikaz + " " + tempFakt;
                                //pridanie do zoznamu filtrovanych pravidiel
                                filterPravidiel.add(filterFakt);
                            }
                            break;
                        case "vymaz":
                            if (Pamat.contains(tempFakt) == true) {
                                String filterFakt = prikaz + " " + tempFakt;
                                //pridanie do zoznamu filtrovanych pravidiel
                                filterPravidiel.add(filterFakt);
                            }
                            break;
                        default:
                            //bude vypisovat spravu
                            if (vypisaneSpravy.contains(tempFakt) == false) {
                                String filterFakt = prikaz + " " + tempFakt;
                                filterPravidiel.add(filterFakt);
                            }
                            break;
                    }
                } // koniec for cyklus pre instanciu

                if (filterPravidiel.isEmpty() == false) {
                    filtrovaneINSTANCIEpravidiel.add(filterPravidiel);
                }
            }// koniec cyklu pre vsetky aplikovatelne akcie

            //samotne vykonavanie
            //vypise zatial na pracovnu plochu
            // System.out.println("Aplikovatelne instancie: ");
// temporaryVYPIS.append("\n-------------------------------");
            // temporaryVYPIS.append("\nAPLIKOVATELNE INSTANCIE: " + "\n");
            VYPIS_APLIKOVATELNE.append("\n----------------------------");
            VYPIS_APLIKOVATELNE.append("\nAPLIKOVATELNE INSTANCIE: " + "\n");

            for (String[] instancie : aplikovatelneAkcie) {
                for (String tmp : instancie) {
                    VYPIS_APLIKOVATELNE.append(tmp).append(" \n");
                }
            }
            //uz filtrovane spravy

            // System.out.println("Filtrovane instancie: ");
            // temporaryVYPIS.append("Filtrovane instancie: " + "\n");
            // VYPIS_FILTROVANE.append("Filtrovane instancie: " + "\n");
            StringBuilder bb = new StringBuilder();
            bb.append("FILTROVANE INSTANCIE:  ").append(filtrovaneINSTANCIEpravidiel.size()).append("\n");
            for (List<String> inst : filtrovaneINSTANCIEpravidiel) {
                for (String tmp : inst) {
                    bb.append(tmp).append(", ");
                    //System.out.print(tmp + " ");
                }
                bb.append("\n");
                // System.out.println("");
            }
            temporaryVYPIS.append("\n-------------------\n");
            temporaryVYPIS.append(bb);

            //jTextPomocnyVystup.setText(bb.toString());
            //jTextPomocnyVystup.setCaretPosition(0);
            //System.out.println("POCET FILTROVANYCH: " + filtrovaneINSTANCIEpravidiel.size());
            //vypisi
            //jTextPomocnyVystup.append("\nvelkost filtrovanych : " + filtrovaneINSTANCIEpravidiel.size());
            //temporaryVYPIS.append("\nPOCET FILTROVANYCH: ").append(filtrovaneINSTANCIEpravidiel.size()).append("\n");
            if (filtrovaneINSTANCIEpravidiel.size() > 0) {
                for (String tmp : filtrovaneINSTANCIEpravidiel.get(0)) {
                    String prikaz = tmp.substring(0, tmp.indexOf(" "));
                    String akcia = tmp.substring(tmp.indexOf(" ") + 1, tmp.length());

                    switch (prikaz) {
                        case "pridaj":
                            //jTextPomocnyVystup.append("Akcia pridaj: " + akcia);
                            temporaryVYPIS.append("pridaj: ").append(akcia).append("\n");
                             // ak uz je pamati vynechavam
                            // ak nie tak ho pridam do pamate
                            if (Pamat.contains(akcia)) {
                                //System.out.println("duplikat: " + akcia);
                                //jTextPomocnyVystup.append("duplikat: " + akcia);
                                temporaryVYPIS.append("duplikat: ").append(akcia).append("\n");
                            } else {
                                //System.out.println("pridavam: " + akcia);
                                temporaryVYPIS.append("pridavam: ").append(akcia).append("\n");
                                Pamat.add(akcia);
                                refreshPamatVypis();
                            }
                            break;
                        case "vymaz":
                            //System.out.println("Akcia vymaz: " + akcia);
                            temporaryVYPIS.append("vymaz: ").append(akcia).append("\n");

                            //ak danu akciu najdeme 
                            // vymazem s pamate ak tam nie je nic nevykona
                            if (Pamat.contains(akcia)) {
                                //System.out.println("vymazat: " + akcia);
                                temporaryVYPIS.append("vymazat: ").append(akcia).append("\n");
                                Pamat.remove(akcia);
                                refreshPamatVypis();
                            } else {
                                //System.out.println("fakt neexistuje: " + akcia);
                                temporaryVYPIS.append("fakt neexistuje: ").append(akcia).append("\n");
                            }
                            break;
                        case "sprava":
                            //na vypisanie vyslednej spravy
                            vypisaneSpravy.add(akcia);
                            ///System.out.println("Akcia sprava: " + akcia);
                            temporaryVYPIS.append("sprava: ").append(akcia).append("\n");
                            jTextSprava.append(akcia + "\n");
                            break;
                    }
                }
            }
        } while (filtrovaneINSTANCIEpravidiel.size() > 0);

        //aktualnu pracovnu plochu vypis
        jTextPomocnyVystup.append(temporaryVYPIS.toString() + "\n");
        jTextPomocnyVystup.append("-----------------------------\n");
    } // koniec tried WORKING

    //prehladavanie 
    public void searching(String meno, List<String> podmienka, List<String> akcia, List<String[]> naviazania) {
        // ak sme vsetky podmienky naviazali 
        // musime prehladat akcie, a vytvorit instanciu pravidla
        if (podmienka.isEmpty() == true) {
            int length = akcia.size();
            int pocetAkcii = 0;
            String[] instPravidla = new String[length];

            for (String a : akcia) {
                String[] fakt = a.split(" ");
                //zistujem ci sa podmienka podoba
                for (int i = 0; i < fakt.length; i++) {
                    if (fakt[i].startsWith("?") == true) {
                        String name = fakt[i];
                        for (String[] naviazanie : naviazania) {
                            if (name.equals(naviazanie[0]) == true) {
                                fakt[i] = naviazanie[1];
                            }
                        }
                    }
                }
                String newFakt = new String();
                for (int i = 0; i < fakt.length; i++) {
                    if (newFakt.equals("") == false) {
                        newFakt += " ";
                    }
                    newFakt += fakt[i];
                }
                instPravidla[pocetAkcii++] = newFakt;
            } // koniec cyklu pre vsetky akcie
            aplikovatelneAkcie.add(instPravidla);
            return;
        } // end IF isEmpty()
        String[] podmienk = podmienka.get(0).split(" ");

        if (podmienk[0].equals("<>") == true) {
            String op_prvy = podmienk[1];
            String op_druhy = podmienk[2];
            String nazov_prvy = null;
            String nazov_druhy = null;

            for (String[] spoj : naviazania) {
                if (op_prvy.equals(spoj[0]) == true) {
                    nazov_prvy = spoj[1];
                }
                if (op_druhy.equals(spoj[0]) == true) {
                    nazov_druhy = spoj[1];
                }
            }
            if (nazov_prvy.equals(nazov_druhy) == false) {
                List<String> novaPodmienky = new ArrayList<>(); //vytvorKOPIU(podmienka);
                // vytvori novu kopiu a s tou to bude kontrolovat
                for (String prvok : podmienka) {
                    String novz = new String(prvok);
                    novaPodmienky.add(novz);
                }
                novaPodmienky.remove(0);
                //rekurzivne vyhlada s novou podmienkou
                searching(meno, novaPodmienky, akcia, naviazania);
            }
        } else {
            for (int y = 0; y < Pamat.size(); y++) {
                String[] fakt = Pamat.get(y).split(" ");
                boolean zhoda = true;
                for (int i = 0; i < fakt.length; i++) {
                    if (podmienk[i].startsWith("?") == false && podmienk[i].equals(fakt[i]) == false) {
                        zhoda = false;
                    }
                    if (zhoda == false) {
                        break;
                    }
                }
                if (zhoda == false) {
                    continue;
                }

                List<String[]> noveNaviazania = new ArrayList<>();

                for (int i = 0; i < fakt.length; i++) {
                    if (podmienk[i].startsWith("?") == true) {
                        String[] naviazanie = new String[]{podmienk[i], fakt[i]};
                        noveNaviazania.add(naviazanie);
                    }
                }
                boolean vhodne = true;
                // ziskal som nove naviazania , zoznam nove Naviazania 
                // skontrolujem ci existuju
                for (String[] naviaz : naviazania) {
                    for (int i = 0; i < noveNaviazania.size(); i++) {
                        if (naviaz[0].equals(noveNaviazania.get(i)[0]) == true && naviaz[1].equals(noveNaviazania.get(i)[1]) == true) {
                            noveNaviazania.remove(i);
                            i--;
                            continue;
                        } else if (naviaz[0].equals(noveNaviazania.get(i)[0]) == true || naviaz[1].equals(noveNaviazania.get(i)[1]) == true) {
                            //preskoci toto pravidlo
                            vhodne = false;
                            break;
                        }
                    }

                }
                if (vhodne == false) {
                    continue;
                }

                List<String[]> novejsieNaviazania = new ArrayList<>();

                //kopirovanie
                for (String[] prvok : naviazania) {
                    String[] novy = new String[prvok.length];
                    for (int i = 0; i < prvok.length; i++) {
                        novy[i] = new String(prvok[i]);
                    }
                    novejsieNaviazania.add(novy);
                }

                for (String[] spoje : noveNaviazania) {
                    novejsieNaviazania.add(spoje);
                }

                List<String> novePodmienky = new ArrayList<>();
                //dalsie kopirovanie
                for (String prvok : podmienka) {
                    String novy = new String(prvok);
                    novePodmienky.add(novy);
                }
                novePodmienky.remove(0);

                //znova prehladavaj ale s novymi parametrami
                searching(meno, novePodmienky, akcia, novejsieNaviazania);
            }
        }
    }

    public void refreshPamatVypis() {
        StringBuilder bb = new StringBuilder();
        for (String s : Pamat) {
            bb.append(s).append("\n");
        }
        jTextFakty.setText(bb.toString());
        jTextFakty.setCaretPosition(0);
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;

                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Frame.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Frame.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Frame.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Frame.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Frame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jBtnJedenKrok;
    private javax.swing.JButton jBtnNacitajFakty;
    private javax.swing.JButton jBtnNacitajPravidla;
    private javax.swing.JButton jBtnVsetkyKroky;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JTextArea jTextFakty;
    private javax.swing.JTextArea jTextPomocnyVystup;
    private javax.swing.JTextArea jTextPravidla;
    private javax.swing.JTextArea jTextSprava;
    // End of variables declaration//GEN-END:variables
}
